####qt5.15.2
cd ~/Downloads 
wget https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz
tar -Jxvf qt-everywhere-src-5.15.2.tar.gz -C ~
cd ~/qt-everywhere-src-5.15.2/

#依赖包安装
sudo apt update
sudo apt install \
  build-essential libxcb1-dev libx11-xcb-dev \
  '^libxcb.*-dev' libxkbcommon-dev libxkbcommon-x11-dev \
  libxcb-xfixes0-dev libxcb-util-dev libxcb-render0-dev \
  libxcb-shape0-dev libxcb-image0-dev \
  libgl1-mesa-dev libglu1-mesa-dev \
  libwayland-dev libwayland-client0 libwayland-server0 \
  libwayland-cursor0 wayland-protocols libwayland-egl-backend-dev libglfw3-dev

#配置Qt编译参数

##注意配置时可能出现错误，此时需要修改相应的源码文件，
# 报std::numeric_limits的错误，相应源码文件添加#inlcude<limits>
# 报std::min、std::max的，相应源码文件添加#include<algorithm>

## ./configure \
##     -prefix /usr/local               # 安装到指定目录\
##     -opensource -confirm-license     # 接受开源协议，无交互\
##     -nomake examples -nomake tests   # 不编译示例和单元测试，加快速度\
##     -skip qtwebengine                # WebEngine包含了完整的Chromium子系统，体积大（几个G），编译时间长，非必要可以不编译 \
##     -xcb                          # 强制编译 XCB 插件（可选）\
##     -opengl dynamic                  # 动态加载 OpenGL/ANGLE（支持 EGL）\
##     -no-feature-vulkan               # 如果不需要 Vulkan，可禁用\
##     -dbus-linked                     # D-Bus 支持，Wayland session 常用\
##     -system-zlib -system-libpng      # 用系统库，不编 Qt 自带的压缩PNG \
##      -release                        # 发布版本 


./configure \
  -prefix /usr/local \
  -opensource -confirm-license \
  -nomake examples -nomake tests \
  -skip qtwebengine \
  -xcb \
  -opengl dynamic \
  -no-feature-vulkan \
  -dbus-linked \
  -system-zlib -system-libpng \
  -release \
  -feature-wayland-client \
  -feature-wayland-server


#####grpc
cd ~
git clone https://github.com/grpc/grpc.git
cd grpc
git submodule update --init --recursive


 cmake -S. -Bbuild \
  -DgRPC_INSTALL=ON \
  -DgRPC_BUILD_TESTS=OFF \
  -DCMAKE_BUILD_TYPE=Release \
  -DgRPC_PROTOBUF_PROVIDER=module \
  -DgRPC_ZLIB_PROVIDER=module       \
  -DCMAKE_INSTALL_PREFIX=/usr/local   

cmake --build build -- -j$(nproc)
sudo cmake --install build 
sudo ldconfig

##boost
cd ~
git clone --recursive https://github.com/boostorg/boost.git
cd boost
./bootstrap.sh --prefix=/usr/local
sudo ./b2 install
###如果只需要特定的库，例如只安装filesystem和system库
#sudo ./b2 install --with-filesystem --with-system
#写入环境变量
echo "#boost环境变量" >> ~/.profile
echo "export LD_LIBRARY_PATH=/usr/local/lib:\$LD_LIBRARY_PATH" >> ~/.profile
source ~/.profile







######redis库 安装
sudo apt update
sudo apt install build-essential tcl pkg-config
wget https://download.redis.io/releases/redis-8.0.2.tar.gz
tar xzf redis-*.tar.gz
cd redis-8.0.2
make -j$(nproc)
sudo make install
#拷贝配置项目， 设置密码：redis.conf找到# requirepass foobared，取消注释，并将foobared改为自己的密码
sudo mkdir /etc/redis -p
sudo cp redis.conf /etc/redis/

#创建用于systemctl的redis文件，根据安装路径填写二进制文件路径
sudo tee /etc/systemd/system/redis.service > /dev/null << 'EOF'
[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
User=redis
Group=redis
Type=forking
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/local/bin/redis-cli shutdown
Restart=always
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF

#创建redis用户, 可选但推荐
#sudo adduser --system --group --no-create-home redis
#sudo chown redis:redis /etc/redis/redis.conf




# redis开发的头文件
sudo apt update
sudo apt install libhiredis-dev






#####jsoncpp
cd ~ && git clone https://github.com/open-source-parsers/jsoncpp.git &&
cd jsoncpp

cmake -S. -Bbuild  \
  -DCMAKE_BUILD_TYPE=Release \
  -DBUILD_SHARED_LIBS=ON \
  -DJSONCPP_WITH_TESTS=OFF \
  -DJSONCPP_WITH_POST_BUILD_UNITTEST=OFF \
  -DJSONCPP_USE_SECURE_MEMORY=OFF  \
  -DCMAKE_CXX_STANDARD=17   \

#查看编译标志，是否启用C++17  
#cat ./build/src/lib_json/CMakeFiles/jsoncpp_object.dir/flags.make
#cat ./build/src/lib_json/CMakeFiles/jsoncpp_lib.dir/flags.make
#cat ./build/src/lib_json/CMakeFiles/jsoncpp_static.dir/flags.make
#也可以在下面的命令中添加-v参数，检查是否使用c++17编译
cmake --build build -- -j$(nproc)
sudo cmake --install build
#验证生成的库是否有string_view版本
nm -D /usr/local/lib/libjsoncpp.so | c++filt | grep string_view
######## mysql
wget https://repo.mysql.com/mysql-apt-config_0.8.34-1_all.deb
sudo dpkg -i mysql-apt-config_0.8.34-1_all.deb
sudo apt update
sudo apt install mysql-server libmysqlclient-dev
sudo apt --fix-broken install
#Package configure记得选上MySQL Connectors，安装必要的头文件和库，以进行代码开发

##首次启动mysql：mysql -u root -p 


#手动安装mysql cppconn库
cd ~
wget https://downloads.mysql.com/archives/get/p/20/file/mysql-connector-c%2B%2B-8.4.0-src.tar.gz
tar -zxvf mysql-connector-c++-8.4.0-src.tar.gz -C ~
cd ~/mysql-connector-c++-8.4.0-src 
cmake -S. -Bbuild \
  -DCMAKE_INSTALL_PREFIX=/usr/local  \
  -DWITH_SSL=system \
  -DBUILD_SHARED_LIBS=ON \
  -DWITH_JDBC=ON \
  -DCMAKE_BUILD_TYPE=Release \
  -DMYSQLCPPCONN_BUILD_EXAMPLES=OFF \
  -DMYSQLCPPCONN_BUILD_TESTS=OFF \
  -DMYSQL_INCLUDE_DIR=/usr/include/mysql   # 根据实际路径调整 \
  -DMYSQL_LIB_DIR=/usr/lib/x86_64-linux-gnu  # 根据实际路径调整



cmake --build build -- -j$(nproc)
cmake --install build


#Mysql里创建表
-- 用于管理全局 uid，不加 AUTO_INCREMENT
-- id 无需设置主键自增，只需要初始有一条记录保证存储过程可以工作即可
-- user_id用于支持跨表id管理、提前获取id等
CREATE TABLE user_id (
    id INT NOT NULL
);

-- 初始化一条记录，值为 0
INSERT INTO user_id (id) VALUES (0);

-- 用户表
CREATE TABLE user (
    uid INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    pwd VARCHAR(255) NOT NULL,
    nick VARCHAR(255),
    icon VARCHAR(255)
);

-- 初始化user_id, 至少要有一条记录，否则存储过程无法工作 
INSERT INTO user_id (id) VALUES (0);  


#存储过程，在命令行中操作
USE light_chat_db;
DELIMITER //
CREATE DEFINER=`crain`@`localhost` PROCEDURE `reg_user`(
    IN `new_name` VARCHAR(255), 
    IN `new_email` VARCHAR(255), 
    IN `new_pwd` VARCHAR(255), 
    OUT `result` INT)
BEGIN
    -- 如果在执行过程中遇到任何错误，则回滚事务
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 回滚事务
        ROLLBACK;
        -- 设置返回值为-1，表示错误
        SET result = -1;
    END;
    
    -- 开始事务
    START TRANSACTION;

    -- 检查用户名是否已存在
    IF EXISTS (SELECT 1 FROM `user` WHERE `name` = new_name) THEN
        SET result = 0; -- 用户名已存在
        COMMIT;
    ELSE
        -- 用户名不存在，检查email是否已存在
        IF EXISTS (SELECT 1 FROM `user` WHERE `email` = new_email) THEN
            SET result = 0; -- email已存在
            COMMIT;
        ELSE
            -- email也不存在，更新user_id表
            -- ****如果user_id里没有记录， 之后就会出错，因为表里根本没有数据，结果集为空, 触发异常并结束
            -- 更新user_id表的记录，并非插入新几率，表中只有一条记录表示最新未分配id
            UPDATE `user_id` SET `id` = `id` + 1;
            
            -- 获取更新后的id
            SELECT `id` INTO @new_id FROM `user_id`;
            
            -- 在user表中插入新记录
            INSERT INTO `user` (`uid`, `name`, `email`, `pwd`) VALUES (@new_id, new_name, new_email, new_pwd);
            -- 设置result为新插入的uid
            SET result = @new_id; -- 插入成功，返回新的uid
            COMMIT;
        
        END IF;
    END IF;
END //
DELIMITER ;

#注册用户测试
CALL reg_user('zhangsan', 'zhangsan@example.com', 'mypassword', @reg_result);
